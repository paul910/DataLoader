import glob
import gzip
import os
import pickle
from collections import defaultdict

import networkx as nx
import numpy as np
import torch
import torch_geometric
from tqdm import tqdm


class ASTEncoder(object):
    def __init__(self, params, overwrite_cache=False):
        self.params = params
        self.overwrite_cache = params["overwrite_cache"]
        self.cache_dir = "cache/ASTTYPES"

        if not os.path.exists(self.cache_dir):
            os.mkdir(self.cache_dir)

    def _get_cache_path(self):
        return os.path.join(self.cache_dir, "asttypes.pkl.gz")

    def _clean(self, s):
        if len(s) > 0 and s[0] == s[-1] and s[0] in ["'", '"']:
            return s[1:-1].strip()
        return s.strip()

    def get_asttypes(self):
        if os.path.isfile(self._get_cache_path()) and not self.overwrite_cache:
            with gzip.open(self._get_cache_path(), "r") as f:
                return pickle.load(f)
        asttypes = defaultdict(int)
        for directory in self.params["files"]:
            cpg_files = list(glob.glob(os.path.join(directory, "**", "*.cpg")))
            assert len(cpg_files) > 0, "Must find cpg files for AST labels"

            print(f"Loading cpg files for {directory}")
            for path in tqdm(cpg_files):
                with open(path, "r", encoding='utf-8', errors='ignore') as f:
                    graph = read_dot(f)

                    for node_id in graph:
                        node = graph.nodes[node_id]
                        if node.get("label") is None:
                            asttypes["UNKNOWN"] += 1
                            continue
                        asttypes[self._clean(node["label"])] += 1

        with gzip.open(self._get_cache_path(), "w") as f:
            pickle.dump(asttypes, f)
        return asttypes


def read_dot(f):
    return nx.Graph(nx.drawing.nx_pydot.read_dot(f))


def from_networkx_multi(G):
    # original code: https://pytorch-geometric.readthedocs.io/en/latest/_modules/torch_geometric/utils/convert.html#from_networkx
    # adapted to multigraphs

    G = nx.convert_node_labels_to_integers(G)
    G = G.to_directed() if not nx.is_directed(G) else G
    edge_index = torch.LongTensor(list(G.edges)).t().contiguous()
    if isinstance(G, (nx.MultiDiGraph, nx.MultiGraph)):
        edge_index = edge_index[0:2, :]

    data = {}

    for i, (_, feat_dict) in enumerate(G.nodes(data=True)):
        for key, value in feat_dict.items():
            data[str(key)] = [value] if i == 0 else data[str(key)] + [value]

    for i, (_, _, feat_dict) in enumerate(G.edges(data=True)):
        for key, value in feat_dict.items():
            data[str(key)] = [value] if i == 0 else data[str(key)] + [value]

    for key, item in data.items():
        try:
            if type(item) is list and len(item) > 0 and type(item[0]) is np.ndarray:
                item = np.stack(item)
            data[key] = torch.tensor(item)
        except ValueError:
            pass

    data['edge_index'] = edge_index.view(2, -1)
    data = torch_geometric.data.Data.from_dict(data)
    data.num_nodes = G.number_of_nodes()

    return data
